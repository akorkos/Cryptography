\documentclass[aspectratio=169]{beamer}
\usepackage{settings}

\title{Presentation for NGE-06-03}
\subtitle{\emph{Tools for lattice based cryptography: LLL \& BKZ - Algorithms}}
\author{Alexandros Korkos}
\institute{Aristotle University of Thessaloniki \\ Computer Science Department}
\date{\today}

\begin{document}

    \begin{frame}
      \vfilll
      \titlepage
      \vfilll
      \usebeamerfont{institute} \textbf{Contact:} \href{mailto:alexkork@csd.auth.gr}{alexkork@csd.auth.gr}
    \end{frame}

    \input{abstract.tex}

    \begin{frame}{Overview}
        \tableofcontents[currentsection, hideothersubsections, sectionstyle=show/show]
    \end{frame}

    \section{Lattice - based cryptography}

    \begin{frame}{Introduction}
        \begin{block}{Lattice - based cryptography}
            Lattice-based cryptographic constructions hold a great promise for post-quantum cryptography, as they enjoy very strong security proofs based on worst-case hardness, relatively efficient implementations, as well as great simplicity. In addition, lattice-based cryptography is believed to be secure against quantum computers.
        \end{block}

        Some lattice based schemes:

        \begin{itemize} 
            \item NTRU encryption scheme
            \item GGH encryption scheme
            \item The Ajtai-Dwork Public Key Cryptosystem
            \item ...
        \end{itemize}
        
    \end{frame}

    \begin{frame}{Lattice (1)}
        \begin{center}
            \textbf{So what is a lattice?}
        \end{center}

        \begin{block}{Lattice}
            Given n-linearly independent vectors $\mathbf{b_1, b_2, ..., b_n} \in \mathbb{R}^n$, the lattice generated by them is the set of vectors

            \[
                \mathcal{L}(\mathbf{b_1, ..., b_n}) = \bigg\{ \sum_{i=1}^{n} x_i\mathbf{b_i}: x_i \in \mathbb{Z} \bigg\}
            \]

            The vectors $\mathbf{b_1, b_2, ..., b_n}$ are known as a basis of the lattice.
        \end{block}
    \end{frame}

    \begin{frame}{Lattice (2)}
        \begin{figure}
            \centering
            \includesvg[scale=0.4]{images/lattice.svg}
            \caption{A two-dimensional lattice and two possible bases.}
            \label{fig:lattice}
        \end{figure}
    \end{frame}

    \begin{frame}{Lattice reduction}
        \begin{block}{Lattice reduction}
            It aims to find a basis that minimizes the length of the lattice vectors while preserving the important properties of the lattice, or more generally finding reasonably short vectors and reasonably good bases.
        \end{block}
    
        \begin{block}{Lattice reduction problems}
            The most well known computational problems on lattices are the following:
            \begin{itemize}
                \item Shortest Vector Problem (SVP): Given a lattice basis $\mathbf{B}$, find the shortest nonzero vector in $\mathcal{L}(\mathbf{B})$.
                \item Closest Vector Problem (CVP)
                \item Shortest Independent Vectors Problem (SIVP)
            \end{itemize}
        \end{block}

        One of the best algorithms for lattice reduction and for solving the Shortest Vector Problem (SVP) is the LLL - Algorithm.
    \end{frame}

    \section{LLL - Algorithm}
    \subsection{Introduction}
    
    \begin{frame}{LLL - Algorithm}
        The LLL algorithm, short for Lenstra-Lenstra-Lovász algorithm, was introduced by Arjen Lenstra, Hendrik Lenstra, and László Lovász in 1982. 

        \hfill
        
        One the key attributes of the LLL, is its \emph{polynomial} time for lattice reducing. 
        
        \begin{block}{}
            More precise, given an integral basis $\mathbf{B} \in \mathbb{Z}^{n\times n}$ , the LLL algorithm outputs an LLL-reduced basis of $\mathcal{L} = \mathcal{L}(\mathbf{B})$ in time $poly(n, |\mathbf{B}|)$, where $|\mathbf{B}|$ denotes the bit length of the input basis.
        \end{block}

        \hfill

        The LLL - Algorithm, finds an approximate solution to SVP. The SVP is still reaming as $\mathcal{NP} - hard$.

    \end{frame}

    \subsection{Definition of LLL}
    
    \begin{frame}{Definition of LLL}
        \begin{definition}
            Let $\mathbf{\{b_1, b_2, ..., b_n\}}$ be a basis for a $n$-dimensional Lattice $\mathcal{L}$, and $\mathbf{\{b_1^*, b_2^*, ..., b_n^*\}}$ be a orthogonal basis, and we have $\mu_{i,j} = \frac{\mathbf{b_j \cdot b_i^*}}{\mathbf{b_i^* \cdot b_i^*}}$. We say $\mathbf{\{b_1, b_2, ...,b_n\}}$ is a LLL reduced basis if it satisfies two conditions:
            \begin{enumerate}
                \item $|\mu_{i,j}| \leq \frac{1}{2}, \forall 1 \leq j < i \leq n$ (Size-reduction condition)  
                \item $\delta\|\mathbf{b_{k-1}^*}\|^2 \leq \|\pi_{k-1}(\mathbf{b_k})\|^2, \forall k \in [2, n]$ (Lovász condition).
            \end{enumerate}
        \end{definition}
        
    \end{frame}

    \subsection{Implementation of LLL}

    \begin{frame}[fragile]{Implementation of LLL}
        \begin{algorithm}[H]
            \caption{LLL - Algorithm}
            \label{alg:LLL}
            \SetKwInOut{Input}{Input}
            \SetKwInOut{Output}{Output}

            \Input{A basis $\mathbf{B} = \{\mathbf{b_1, b_2, ..., b_n}\}$ of a lattice $L$, and a reduction parameter $\delta \in (0.25, 1]$}
            \Output{A $\delta$ - LLL reduced basis $\mathcal{L}(\mathbf{B})$}

            Compute Gram–Schmidt information $\mu_{i, j}$ and $\| \mathbf{b_i^*} \| ^ 2$ of the input basis $B$ \\
            $k = 2$ \\
            \While{$k \leq n$}{
                // At each k, we recursively change $\mathbf{b_k = b_k} - \lfloor \mu_{k,j} \rceil \mathbf{b_j}$ for $ j \in [1, k - 1]$ \\
                Size-reduce $\mathbf{B}$ \\
                \If{$\delta\|\mathbf{b_{k-1}^*}\|^2 \leq \|\pi_{k-1}(\mathbf{b_k})\|^2$}{
                    $k = k + 1$ \\
                }
                \Else{
                    Swap $\mathbf{b_k}$ with $\mathbf{b_{k-1}}$ , and update Gram–Schmidt information of $\mathbf{B}$ \\
                    $k = \max(k - 1, 2)$ \\
                }
            }
        \end{algorithm}
    \end{frame}

    \section{BKZ - Algorithm}
    \subsection{Introduction}

    \begin{frame}{BKZ - Algorithm}

        The first version of BKZ algorithm was proposed by Schnorr and Euchner in 1994 as a generalization of the LLL algorithm

        \hfill

        The BKZ algorithm finds a $\beta$-BKZ-reduced basis, and it calls LLL to reduce every local block before finding the shortest vector over the block lattice. (As $\beta$ increases, a shorter lattice vector can be found, but the running time is more costly.)

        \hfill

        BKZ has \emph{exponential} complexity versus the \emph{polynomial} complexity of the LLL reduction algorithm.
    \end{frame}

    \subsection{Implementation of BKZ}

    \begin{frame}[fragile]{Implementation of BKZ}
        \begin{algorithm}[H]
            \caption{BKZ - Algorithm}
            \label{alg:BKZ}
            \SetKwInOut{Input}{Input}
            \SetKwInOut{Output}{Output}

            \Input{A basis $\mathbf{B} = \{\mathbf{b_1, b_2, ..., b_n}\} \text{ of a lattice L, a blocksize } \beta \in [2, n], \text{and a reduction parameter} \delta \in (0.25, 1] \text{ of LLL}$}
            \Output{A $\beta$ - BKZ reduced basis $\mathcal{L}(\mathbf{B})$}

            $\mathbf{B} = LLL(\mathbf{B}, \delta)$ \\
            $z = 0, j = 0$ \\
            \While{$z < n - 1$}{
                $j = (j \mod (n - 1)) + 1, k = \min(j + \beta - 1, n), h = \min(k + 1, n)$ \\
                Find $\mathbf{v} \in L$ such that $\|\pi_j(\mathbf{v})\| = \lambda_1(L_{[j,k]})$ by enumeration or sieve \\
                \If{$\| \pi_j(\mathbf{v})\|^2 < \|\mathbf{b_j^*}\|^2$}{
                    $z = 0$ and call $LLL((\mathbf{b_1, ..., b_{j-1}, v, b_j , ..., b_h}), \delta$) 
                }
                \Else{
                    $z = z + 1$ and call $LLL((\mathbf{b_1, ..., b_h}), \delta)$
                }
            }
        \end{algorithm}
    \end{frame}

    \section{Summary}
    \subsection{Comparison}

    \begin{frame}{Comparison}
        \begin{center}
            \textbf{Lattice reduction comes in flavours.}
        \end{center}

        If we examine: 
        \begin{itemize}
            \item Reduction Quality:
                The BKZ algorithm can achieve significantly better reduction quality compared to LLL. It strives to find a basis with shorter and more orthogonal lattice vectors.
            \item Computational Complexity:
                The BKZ algorithm has a higher computational complexity (\emph{exponential}) compared to LLL (\emph{polynomial}).
        \end{itemize}
    \end{frame}

    \subsection{Conclusion}

    \begin{frame}{Conclusion}
        \begin{block}{}
            In summary, the LLL algorithm is suitable for many practical applications, offering a good balance between reduction quality and computational efficiency. On the other hand, the BKZ algorithm is employed when stronger reductions are needed, especially in lattice-based cryptography, despite its higher computational cost.
        \end{block} 
    \end{frame}

    \begin{frame}{References}
    
    \footnotesize{
        \begin{thebibliography}{99}
            \bibitem[Yasuda, 2021]{my} Masaya Yasuda (2021)
            \newblock A Survey of Solving SVP Algorithms and Recent Strategies for Solving the SVP Challenge
            \newblock \emph{International Symposium on Mathematics, Quantum Theory, and Cryptography}.
            \bibitem[Micciancio, 2008]{dm} Daniele Micciancio, Oded Regev (2008)
            \newblock Lattice-based Cryptography
            %\newblock \emph{International Symposium on Mathematics, Quantum Theory, and %Cryptography}.
            \bibitem[Wang, 2013]{yw} Yan Wang (2013)
            \newblock Lecture 3: LLL, Coppersmith
            \newblock \emph{Lattices in Cryptography}.
        \end{thebibliography}
    }
    \end{frame}

    \begin{frame}
        \Huge{\centerline{\textbf{The End}}}
    \end{frame}
\end{document}
